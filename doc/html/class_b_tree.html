<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BTreeJS: BTree&lt; Key, Value, Compare &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">BTreeJS
   </div>
   <div id="projectbrief">B+Tree for Nodejs implemented with V8 API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('class_b_tree.html','','class_b_tree-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">BTree&lt; Key, Value, Compare &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A templated B-Tree container for sorted key/value storage.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="btree_8h_source.html">btree.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:InternalNode" id="r_InternalNode"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_tree_1_1_internal_node.html">InternalNode</a></td></tr>
<tr class="memitem:Iterator" id="r_Iterator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree_1_1_iterator.html">Iterator</a></td></tr>
<tr class="memitem:LeafNode" id="r_LeafNode"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_tree_1_1_leaf_node.html">LeafNode</a></td></tr>
<tr class="memitem:Node" id="r_Node"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_tree_1_1_node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a single node in the B-Tree.  <a href="struct_b_tree_1_1_node.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac7841baccc584bd46c5ddbaa269c7c69" id="r_ac7841baccc584bd46c5ddbaa269c7c69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7841baccc584bd46c5ddbaa269c7c69">BTree</a> (const Compare &amp;comp=Compare{})</td></tr>
<tr class="memdesc:ac7841baccc584bd46c5ddbaa269c7c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty B-Tree with a custom comparator.  <br /></td></tr>
<tr class="memitem:adfb513daae74e467d51c9bf88af2596a" id="r_adfb513daae74e467d51c9bf88af2596a"><td class="memItemLeft" align="right" valign="top">Value &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfb513daae74e467d51c9bf88af2596a">operator[]</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:adfb513daae74e467d51c9bf88af2596a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the value associated with a key. This does a search behind the scenes so don't use it for repeated access, instead loop over the iterator and do your custom logic there.  <br /></td></tr>
<tr class="memitem:a4a1d1d6517f181018efa489d009d0fcc" id="r_a4a1d1d6517f181018efa489d009d0fcc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a1d1d6517f181018efa489d009d0fcc">size</a> () const</td></tr>
<tr class="memdesc:a4a1d1d6517f181018efa489d009d0fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of key/value pairs stored in the tree.  <br /></td></tr>
<tr class="memitem:a1f618d0a26ec20a12ad3b05e06c78970" id="r_a1f618d0a26ec20a12ad3b05e06c78970"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f618d0a26ec20a12ad3b05e06c78970">insert</a> (const Key &amp;key, const Value &amp;value)</td></tr>
<tr class="memdesc:a1f618d0a26ec20a12ad3b05e06c78970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a key/value pair into the tree.  <br /></td></tr>
<tr class="memitem:a6ac491a77f862fa00a94cf7a688d7e48" id="r_a6ac491a77f862fa00a94cf7a688d7e48"><td class="memItemLeft" align="right" valign="top">Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ac491a77f862fa00a94cf7a688d7e48">search</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:a6ac491a77f862fa00a94cf7a688d7e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the value associated with a given key.  <br /></td></tr>
<tr class="memitem:a0a0989a366b92907a8389360532e201b" id="r_a0a0989a366b92907a8389360532e201b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a0989a366b92907a8389360532e201b">remove</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:a0a0989a366b92907a8389360532e201b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the entry with the specified key.  <br /></td></tr>
<tr class="memitem:a7dd69dade4718a185d457a71d855b517" id="r_a7dd69dade4718a185d457a71d855b517"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; const Key *, Value * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7dd69dade4718a185d457a71d855b517">range</a> (const Key &amp;low, const Key &amp;high)</td></tr>
<tr class="memdesc:a7dd69dade4718a185d457a71d855b517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects all entries whose keys are within [low, high], inclusive.  <br /></td></tr>
<tr class="memitem:a50a547458b425a5d3edbf31cbe6d350e" id="r_a50a547458b425a5d3edbf31cbe6d350e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; const Key *, Value * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50a547458b425a5d3edbf31cbe6d350e">range</a> (const Key &amp;low, size_t count)</td></tr>
<tr class="memdesc:a50a547458b425a5d3edbf31cbe6d350e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects up to <span class="tt">count</span> entries starting at key ≥ low.  <br /></td></tr>
<tr class="memitem:ae19db29abae4b851f8fe671356e6f3e5" id="r_ae19db29abae4b851f8fe671356e6f3e5"><td class="memItemLeft" align="right" valign="top"><a id="ae19db29abae4b851f8fe671356e6f3e5" name="ae19db29abae4b851f8fe671356e6f3e5"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>serializeToJson</b> () const</td></tr>
<tr class="memitem:a150e650122b9926ad7bcfcacda0046d8" id="r_a150e650122b9926ad7bcfcacda0046d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_tree_1_1_iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a150e650122b9926ad7bcfcacda0046d8">begin</a> ()</td></tr>
<tr class="memdesc:a150e650122b9926ad7bcfcacda0046d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first (smallest) element.  <br /></td></tr>
<tr class="memitem:a0346e361fbb10fa5827c8c00a9cea2e1" id="r_a0346e361fbb10fa5827c8c00a9cea2e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_tree_1_1_iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0346e361fbb10fa5827c8c00a9cea2e1">end</a> () noexcept</td></tr>
<tr class="memdesc:a0346e361fbb10fa5827c8c00a9cea2e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator one past the last element.  <br /></td></tr>
<tr class="memitem:aa50d6c9e08298d36f086cbc582e8241d" id="r_aa50d6c9e08298d36f086cbc582e8241d"><td class="memItemLeft" align="right" valign="top">std::reverse_iterator&lt; <a class="el" href="class_b_tree_1_1_iterator.html">Iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa50d6c9e08298d36f086cbc582e8241d">rbegin</a> ()</td></tr>
<tr class="memdesc:aa50d6c9e08298d36f086cbc582e8241d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the last (largest) element.  <br /></td></tr>
<tr class="memitem:ac6b60d197dd19c852555521973110479" id="r_ac6b60d197dd19c852555521973110479"><td class="memItemLeft" align="right" valign="top">std::reverse_iterator&lt; <a class="el" href="class_b_tree_1_1_iterator.html">Iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6b60d197dd19c852555521973110479">rend</a> () noexcept</td></tr>
<tr class="memdesc:ac6b60d197dd19c852555521973110479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator one past the first (smallest) element.  <br /></td></tr>
<tr class="memitem:a6539ce4056146a8bfdfb9cac1e31cac6" id="r_a6539ce4056146a8bfdfb9cac1e31cac6"><td class="memItemLeft" align="right" valign="top"><a id="a6539ce4056146a8bfdfb9cac1e31cac6" name="a6539ce4056146a8bfdfb9cac1e31cac6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~BTree</b> ()</td></tr>
<tr class="memdesc:a6539ce4056146a8bfdfb9cac1e31cac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the B-Tree, freeing all internal nodes. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-attribs" class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aa466823af040ada3f5a56574e337a526" id="r_aa466823af040ada3f5a56574e337a526"><td class="memItemLeft" align="right" valign="top"><a id="aa466823af040ada3f5a56574e337a526" name="aa466823af040ada3f5a56574e337a526"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>s_CAPACITY</b> = 32</td></tr>
<tr class="memdesc:aa466823af040ada3f5a56574e337a526"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of entries per node. <br /></td></tr>
<tr class="memitem:a2de122770563bbd88ed5d46dd97073ad" id="r_a2de122770563bbd88ed5d46dd97073ad"><td class="memItemLeft" align="right" valign="top"><a id="a2de122770563bbd88ed5d46dd97073ad" name="a2de122770563bbd88ed5d46dd97073ad"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>s_MAX_KEYS</b> = 2 * <a class="el" href="#aa466823af040ada3f5a56574e337a526">s_CAPACITY</a> - 1</td></tr>
<tr class="memitem:aaa884242c735d551a0fb2350adfd7bf8" id="r_aaa884242c735d551a0fb2350adfd7bf8"><td class="memItemLeft" align="right" valign="top"><a id="aaa884242c735d551a0fb2350adfd7bf8" name="aaa884242c735d551a0fb2350adfd7bf8"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>s_MAX_CHILDREN</b> = 2 * <a class="el" href="#aa466823af040ada3f5a56574e337a526">s_CAPACITY</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pri-methods" class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a644946dc5c2b58a1c7ddf8d52fa1b2e8" id="r_a644946dc5c2b58a1c7ddf8d52fa1b2e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a644946dc5c2b58a1c7ddf8d52fa1b2e8">splitChild</a> (<a class="el" href="struct_b_tree_1_1_node.html">Node</a> *parent, size_t index)</td></tr>
<tr class="memitem:a760c03d4ce002fdc71a531e2c47b420b" id="r_a760c03d4ce002fdc71a531e2c47b420b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a760c03d4ce002fdc71a531e2c47b420b">insertNonFull</a> (<a class="el" href="struct_b_tree_1_1_node.html">Node</a> *node, const Key &amp;key, const Value &amp;value)</td></tr>
<tr class="memitem:a6a530f1aca4a6ab8d2009ea5e3dde846" id="r_a6a530f1aca4a6ab8d2009ea5e3dde846"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a530f1aca4a6ab8d2009ea5e3dde846">rebalanceLeaf</a> (<a class="el" href="struct_b_tree_1_1_node.html">Node</a> *leaf, <a class="el" href="struct_b_tree_1_1_node.html">Node</a> *parent, size_t index)</td></tr>
<tr class="memitem:af95c5741c674dc4532336c0adab4ea3a" id="r_af95c5741c674dc4532336c0adab4ea3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af95c5741c674dc4532336c0adab4ea3a">rebalanceInternal</a> (<a class="el" href="struct_b_tree_1_1_node.html">Node</a> *node, <a class="el" href="struct_b_tree_1_1_node.html">Node</a> *parent, size_t index)</td></tr>
<tr class="memitem:a4faf55ac6eafe3249ecfea528e2b6940" id="r_a4faf55ac6eafe3249ecfea528e2b6940"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4faf55ac6eafe3249ecfea528e2b6940">removeFromNode</a> (<a class="el" href="struct_b_tree_1_1_node.html">Node</a> *node, const Key &amp;key)</td></tr>
<tr class="memitem:aa53d01b3c5039553df1f1fbe6afbf337" id="r_aa53d01b3c5039553df1f1fbe6afbf337"><td class="memItemLeft" align="right" valign="top">Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa53d01b3c5039553df1f1fbe6afbf337">getPredecessor</a> (<a class="el" href="struct_b_tree_1_1_node.html">Node</a> *node, size_t idx) const</td></tr>
<tr class="memitem:acf3b2d3f85cd319dd01dbffc970614c7" id="r_acf3b2d3f85cd319dd01dbffc970614c7"><td class="memItemLeft" align="right" valign="top">Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf3b2d3f85cd319dd01dbffc970614c7">getSuccessor</a> (<a class="el" href="struct_b_tree_1_1_node.html">Node</a> *node, size_t idx) const</td></tr>
<tr class="memitem:a391b01dbf324db440cc17a77e631a064" id="r_a391b01dbf324db440cc17a77e631a064"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a391b01dbf324db440cc17a77e631a064">fill</a> (<a class="el" href="struct_b_tree_1_1_node.html">Node</a> *node, size_t idx)</td></tr>
<tr class="memitem:a8db0d5ceac0ac47ed3a22ad5ea7b1d94" id="r_a8db0d5ceac0ac47ed3a22ad5ea7b1d94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8db0d5ceac0ac47ed3a22ad5ea7b1d94">borrowFromPrev</a> (<a class="el" href="struct_b_tree_1_1_node.html">Node</a> *node, size_t idx)</td></tr>
<tr class="memitem:aa8547724653e13afd62e9f2ef384ff2a" id="r_aa8547724653e13afd62e9f2ef384ff2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8547724653e13afd62e9f2ef384ff2a">borrowFromNext</a> (<a class="el" href="struct_b_tree_1_1_node.html">Node</a> *node, size_t idx)</td></tr>
<tr class="memitem:aac69f678bcb722552d0123503594b08d" id="r_aac69f678bcb722552d0123503594b08d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac69f678bcb722552d0123503594b08d">mergeNodes</a> (<a class="el" href="struct_b_tree_1_1_node.html">Node</a> *node, size_t idx)</td></tr>
<tr class="memitem:a5dcf22843ae0428dfc1dc6e108955c06" id="r_a5dcf22843ae0428dfc1dc6e108955c06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5dcf22843ae0428dfc1dc6e108955c06">destroyNode</a> (<a class="el" href="struct_b_tree_1_1_node.html">Node</a> *node)</td></tr>
<tr class="memitem:a2f8fc0b0f01e1839ceddd94b278d05ae" id="r_a2f8fc0b0f01e1839ceddd94b278d05ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f8fc0b0f01e1839ceddd94b278d05ae">less</a> (const Key &amp;a, const Key &amp;b) const</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pri-attribs" class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ae2247628055012a287a74e867387907b" id="r_ae2247628055012a287a74e867387907b"><td class="memItemLeft" align="right" valign="top"><a id="ae2247628055012a287a74e867387907b" name="ae2247628055012a287a74e867387907b"></a>
<a class="el" href="struct_b_tree_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>m_Root</b></td></tr>
<tr class="memitem:a57018808061e9c67766f141462cf5a68" id="r_a57018808061e9c67766f141462cf5a68"><td class="memItemLeft" align="right" valign="top"><a id="a57018808061e9c67766f141462cf5a68" name="a57018808061e9c67766f141462cf5a68"></a>
Compare&#160;</td><td class="memItemRight" valign="bottom"><b>m_Comp</b></td></tr>
<tr class="memitem:a7bf66fe9e6409ae8243026de448c2a27" id="r_a7bf66fe9e6409ae8243026de448c2a27"><td class="memItemLeft" align="right" valign="top"><a id="a7bf66fe9e6409ae8243026de448c2a27" name="a7bf66fe9e6409ae8243026de448c2a27"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_Size</b> {0}</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-friends" class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a9830fc407400559db7e7783cc10a9394" id="r_a9830fc407400559db7e7783cc10a9394"><td class="memItemLeft" align="right" valign="top"><a id="a9830fc407400559db7e7783cc10a9394" name="a9830fc407400559db7e7783cc10a9394"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Iterator</b></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Key, typename Value, typename Compare = std::less&lt;Key&gt;&gt;<br />
class BTree&lt; Key, Value, Compare &gt;</div><p>A templated B-Tree container for sorted key/value storage. </p>
<p>Maintains balance by splitting and merging nodes as elements are inserted or removed, allowing efficient logarithmic-time operations.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>Type of the keys stored in the tree. </td></tr>
    <tr><td class="paramname">Value</td><td>Type of the values associated with each key. </td></tr>
    <tr><td class="paramname">Compare</td><td>Functor used to order keys; defaults to <span class="tt">std::less&lt;Key&gt;</span>. </td></tr>
  </table>
  </dd>
</dl>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac7841baccc584bd46c5ddbaa269c7c69" name="ac7841baccc584bd46c5ddbaa269c7c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7841baccc584bd46c5ddbaa269c7c69">&#9670;&#160;</a></span>BTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Compare&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_tree.html">BTree</a>&lt; Key, Value, Compare &gt;<a class="el" href="class_b_tree.html">::BTree</a> </td>
          <td>(</td>
          <td class="paramtype">const Compare &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Compare{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty B-Tree with a custom comparator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>A callable object that returns true if a &lt; b. Defaults to <span class="tt">std::less&lt;Key&gt;</span> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a150e650122b9926ad7bcfcacda0046d8" name="a150e650122b9926ad7bcfcacda0046d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a150e650122b9926ad7bcfcacda0046d8">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Compare&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_tree.html">BTree</a>&lt; Key, Value, Compare &gt;::Iterator <a class="el" href="class_b_tree.html">BTree</a>&lt; Key, Value, Compare &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the first (smallest) element. </p>
<p>Starts a forward in-order traversal of the B+Tree, yielding entries from low keys to high.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_b_tree_1_1_iterator.html">Iterator</a> pointing at the minimum key. </dd></dl>

</div>
</div>
<a id="aa8547724653e13afd62e9f2ef384ff2a" name="aa8547724653e13afd62e9f2ef384ff2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8547724653e13afd62e9f2ef384ff2a">&#9670;&#160;</a></span>borrowFromNext()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Compare&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_tree.html">BTree</a>&lt; Key, Value, Compare &gt;::borrowFromNext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_b_tree_1_1_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Borrows one key–child pair (internal nodes) or one entry (leaf nodes) from the immediate right sibling of the child at index <span class="tt">idx</span>, updating the parent’s separator key to restore B-Tree invariants.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Pointer to the parent node whose child at <span class="tt">idx</span> is underfull. </td></tr>
    <tr><td class="paramname">idx</td><td>Index in <span class="tt">node-&gt;children</span> of the underfull child to which the right sibling will lend. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8db0d5ceac0ac47ed3a22ad5ea7b1d94" name="a8db0d5ceac0ac47ed3a22ad5ea7b1d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db0d5ceac0ac47ed3a22ad5ea7b1d94">&#9670;&#160;</a></span>borrowFromPrev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Compare&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_tree.html">BTree</a>&lt; Key, Value, Compare &gt;::borrowFromPrev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_b_tree_1_1_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Borrows one key–child pair (internal nodes) or one entry (leaf nodes) from the immediate left sibling of the child at index <span class="tt">idx</span>, updating the parent’s separator key to restore B-Tree invariants.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Pointer to the parent node whose child at <span class="tt">idx</span> is underfull. </td></tr>
    <tr><td class="paramname">idx</td><td>Index in <span class="tt">node-&gt;children</span> of the underfull child to which the left sibling will lend. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5dcf22843ae0428dfc1dc6e108955c06" name="a5dcf22843ae0428dfc1dc6e108955c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dcf22843ae0428dfc1dc6e108955c06">&#9670;&#160;</a></span>destroyNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Compare&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_tree.html">BTree</a>&lt; Key, Value, Compare &gt;::destroyNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_b_tree_1_1_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recursively deletes the subtree rooted at <span class="tt">node</span>, freeing all allocated nodes.</p>
<p>This routine traverses each child pointer, invokes itself on that child, then deletes <span class="tt">node</span> itself. It is called by the destructor to teardown the entire tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Pointer to the root of the subtree to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0346e361fbb10fa5827c8c00a9cea2e1" name="a0346e361fbb10fa5827c8c00a9cea2e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0346e361fbb10fa5827c8c00a9cea2e1">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Compare&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_tree.html">BTree</a>&lt; Key, Value, Compare &gt;::Iterator <a class="el" href="class_b_tree.html">BTree</a>&lt; Key, Value, Compare &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator one past the last element. </p>
<dl class="section return"><dt>Returns</dt><dd>End iterator. </dd></dl>

</div>
</div>
<a id="a391b01dbf324db440cc17a77e631a064" name="a391b01dbf324db440cc17a77e631a064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391b01dbf324db440cc17a77e631a064">&#9670;&#160;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Compare&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_tree.html">BTree</a>&lt; Key, Value, Compare &gt;::fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_b_tree_1_1_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ensures that the child at index <span class="tt">idx</span> has at least the minimum number of keys or entries by borrowing from a sibling or merging when underflow occurs.</p>
<p>If the immediate left or right sibling of the underflowing child has enough entries (or keys for internal nodes), this method borrows one and updates the parent’s separator key. If neither sibling can lend, it merges the child with an adjacent sibling and adjusts the parent’s keys and child pointers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Pointer to the parent node whose child may underflow. </td></tr>
    <tr><td class="paramname">idx</td><td>The index in <span class="tt">node-&gt;children</span> of the child to fill. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa53d01b3c5039553df1f1fbe6afbf337" name="aa53d01b3c5039553df1f1fbe6afbf337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53d01b3c5039553df1f1fbe6afbf337">&#9670;&#160;</a></span>getPredecessor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Compare&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_b_tree.html">BTree</a>&lt; Key, Value, Compare &gt;::getPredecessor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_b_tree_1_1_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds the in-order predecessor of the key at the given child index.</p>
<p>Starting from the child pointer at <span class="tt">node-&gt;children[idx]</span>, this method descends down to the rightmost leaf in that subtree and returns its last entry’s key. This key serves as the predecessor for <span class="tt">node-&gt;keys[idx]</span> when replacing or deleting internal-node keys.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Pointer to the internal node whose predecessor is sought. </td></tr>
    <tr><td class="paramname">idx</td><td>Child index in <span class="tt">node-&gt;children</span> from which to start. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest key in the subtree rooted at <span class="tt">node-&gt;children[idx]</span>. </dd></dl>

</div>
</div>
<a id="acf3b2d3f85cd319dd01dbffc970614c7" name="acf3b2d3f85cd319dd01dbffc970614c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf3b2d3f85cd319dd01dbffc970614c7">&#9670;&#160;</a></span>getSuccessor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Compare&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_b_tree.html">BTree</a>&lt; Key, Value, Compare &gt;::getSuccessor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_b_tree_1_1_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds the in-order successor of the key at the given child index.</p>
<p>Starting from the child pointer at <span class="tt">node-&gt;children[idx + 1]</span>, this method descends down to the leftmost leaf in that subtree and returns its first entry’s key. This key serves as the successor for <span class="tt">node-&gt;keys[idx]</span> when replacing or deleting internal-node keys.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Pointer to the internal node whose successor is sought. </td></tr>
    <tr><td class="paramname">idx</td><td>Child index in <span class="tt">node-&gt;children</span> preceding the target subtree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest key in the subtree rooted at <span class="tt">node-&gt;children[idx + 1]</span>. </dd></dl>

</div>
</div>
<a id="a1f618d0a26ec20a12ad3b05e06c78970" name="a1f618d0a26ec20a12ad3b05e06c78970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f618d0a26ec20a12ad3b05e06c78970">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Compare&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_tree.html">BTree</a>&lt; Key, Value, Compare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a key/value pair into the tree. </p>
<p>If the key does not already exist, a new node is created. If the key exists, the insertion is skipped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to insert. </td></tr>
    <tr><td class="paramname">value</td><td>The value to associate with the key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the pair was inserted; false if the key was already present. </dd></dl>

</div>
</div>
<a id="a760c03d4ce002fdc71a531e2c47b420b" name="a760c03d4ce002fdc71a531e2c47b420b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760c03d4ce002fdc71a531e2c47b420b">&#9670;&#160;</a></span>insertNonFull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Compare&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_tree.html">BTree</a>&lt; Key, Value, Compare &gt;::insertNonFull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_b_tree_1_1_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts a key–value pair into a node that is guaranteed not to be full.</p>
<p>This routine handles both leaf and internal nodes:</p><ul>
<li>If <span class="tt">node</span> is a leaf, it finds the correct position, updates an existing entry if the key already exists, or inserts a new one.</li>
<li>If <span class="tt">node</span> is internal, it locates the child slot, pre-splits the child if it’s full, and then recurses into that child.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Pointer to a B-Tree node that has space for at least one more entry. </td></tr>
    <tr><td class="paramname">key</td><td>The key to insert or update. </td></tr>
    <tr><td class="paramname">value</td><td>The value to associate with <span class="tt">key</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if a new entry was inserted (tree size should be incremented), <span class="tt">false</span> if an existing entry was overwritten. </dd></dl>

</div>
</div>
<a id="a2f8fc0b0f01e1839ceddd94b278d05ae" name="a2f8fc0b0f01e1839ceddd94b278d05ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8fc0b0f01e1839ceddd94b278d05ae">&#9670;&#160;</a></span>less()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_tree.html">BTree</a>&lt; Key, Value, Compare &gt;::less </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compares two keys, wrapper function for <span class="tt">Compare m_Comp</span> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first key to compare. </td></tr>
    <tr><td class="paramname">b</td><td>The second key to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a is "less" than b, false otherwise. </dd></dl>

</div>
</div>
<a id="aac69f678bcb722552d0123503594b08d" name="aac69f678bcb722552d0123503594b08d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac69f678bcb722552d0123503594b08d">&#9670;&#160;</a></span>mergeNodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Compare&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_tree.html">BTree</a>&lt; Key, Value, Compare &gt;::mergeNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_b_tree_1_1_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Merges the child at index <span class="tt">idx</span> with its adjacent sibling and removes the sibling.</p>
<p>For leaf nodes, this concatenates both nodes’ entries and stitches the leaf‐level "linked list". For internal nodes, it pulls down the parent’s separator key, appends the right sibling’s keys and children to the left child, and then removes the right sibling pointer and its key from the parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Pointer to the parent node containing the two siblings. </td></tr>
    <tr><td class="paramname">idx</td><td>Index in <span class="tt">node-&gt;children</span> of the left child to merge; its right sibling lives at <span class="tt">idx + 1</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfb513daae74e467d51c9bf88af2596a" name="adfb513daae74e467d51c9bf88af2596a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb513daae74e467d51c9bf88af2596a">&#9670;&#160;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Compare&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Value &amp; <a class="el" href="class_b_tree.html">BTree</a>&lt; Key, Value, Compare &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accesses the value associated with a key. This does a search behind the scenes so don't use it for repeated access, instead loop over the iterator and do your custom logic there. </p>
<p>If the key exists, returns a reference to its value. Otherwise, an out of range exception will be thrown</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to locate or insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the mapped value. </dd></dl>

</div>
</div>
<a id="a7dd69dade4718a185d457a71d855b517" name="a7dd69dade4718a185d457a71d855b517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd69dade4718a185d457a71d855b517">&#9670;&#160;</a></span>range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Compare&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; const Key *, Value * &gt; &gt; <a class="el" href="class_b_tree.html">BTree</a>&lt; Key, Value, Compare &gt;::range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>high</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects all entries whose keys are within [low, high], inclusive. </p>
<p>Performs an in-order traversal to gather matching entries in ascending key order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low</td><td>The lower bound key (inclusive). </td></tr>
    <tr><td class="paramname">high</td><td>The upper bound key (inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of (key pointer, value pointer) pairs for matching entries. </dd></dl>

</div>
</div>
<a id="a50a547458b425a5d3edbf31cbe6d350e" name="a50a547458b425a5d3edbf31cbe6d350e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a547458b425a5d3edbf31cbe6d350e">&#9670;&#160;</a></span>range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Compare&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; const Key *, Value * &gt; &gt; <a class="el" href="class_b_tree.html">BTree</a>&lt; Key, Value, Compare &gt;::range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects up to <span class="tt">count</span> entries starting at key ≥ low. </p>
<p>Traverses the tree in order beginning at the first entry ≥ low, gathering at most <span class="tt">count</span> results.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low</td><td>The starting key (inclusive). </td></tr>
    <tr><td class="paramname">count</td><td>Maximum number of entries to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of (key pointer, value pointer) pairs for the first <span class="tt">count</span> entries ≥ low. </dd></dl>

</div>
</div>
<a id="aa50d6c9e08298d36f086cbc582e8241d" name="aa50d6c9e08298d36f086cbc582e8241d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa50d6c9e08298d36f086cbc582e8241d">&#9670;&#160;</a></span>rbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Compare&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_b_tree.html">BTree</a>&lt; Key, Value, Compare &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the last (largest) element. </p>
<p>Starts a reverse in-order traversal of the B+Tree, yielding entries from high keys down to low.</p>
<dl class="section return"><dt>Returns</dt><dd>A std::reverse_iterator over <a class="el" href="class_b_tree_1_1_iterator.html">Iterator</a>, initially pointing at the maximum key. </dd></dl>

</div>
</div>
<a id="af95c5741c674dc4532336c0adab4ea3a" name="af95c5741c674dc4532336c0adab4ea3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95c5741c674dc4532336c0adab4ea3a">&#9670;&#160;</a></span>rebalanceInternal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Compare&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_tree.html">BTree</a>&lt; Key, Value, Compare &gt;::rebalanceInternal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_b_tree_1_1_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_b_tree_1_1_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rebalances an internal node that has fallen below the minimum key threshold.</p>
<p>This method restores an internal node’s capacity by first attempting to borrow a key–child pair from its immediate left or right sibling. If neither sibling has extra keys, it merges the underfull node with one sibling, pulls down the separator key from the parent, and updates the parent’s keys and child pointers accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Pointer to the internal node that needs rebalancing. </td></tr>
    <tr><td class="paramname">parent</td><td>Pointer to the parent node containing separator keys and references to its children. </td></tr>
    <tr><td class="paramname">index</td><td>The index in <span class="tt">parent-&gt;children</span> where <span class="tt">node</span> is located. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a530f1aca4a6ab8d2009ea5e3dde846" name="a6a530f1aca4a6ab8d2009ea5e3dde846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a530f1aca4a6ab8d2009ea5e3dde846">&#9670;&#160;</a></span>rebalanceLeaf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Compare&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_tree.html">BTree</a>&lt; Key, Value, Compare &gt;::rebalanceLeaf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_b_tree_1_1_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>leaf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_b_tree_1_1_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rebalances a leaf node that has fallen below the minimum entry threshold.</p>
<p>This method restores a leaf’s capacity by first attempting to borrow an entry from its immediate left or right sibling. If neither sibling has spare entries, it merges the underfull leaf with one sibling and updates the parent’s keys and child pointers accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leaf</td><td>Pointer to the leaf node that needs rebalancing. </td></tr>
    <tr><td class="paramname">parent</td><td>Pointer to the parent node containing the separator key and references to its children. </td></tr>
    <tr><td class="paramname">index</td><td>The index in <span class="tt">parent-&gt;children</span> where <span class="tt">leaf</span> is located. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a0989a366b92907a8389360532e201b" name="a0a0989a366b92907a8389360532e201b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a0989a366b92907a8389360532e201b">&#9670;&#160;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Compare&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_tree.html">BTree</a>&lt; Key, Value, Compare &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the entry with the specified key. </p>
<p>Finds the node matching key, removes it, and rebalances the tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the entry to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if an element was removed; false if the key was not found. </dd></dl>

</div>
</div>
<a id="a4faf55ac6eafe3249ecfea528e2b6940" name="a4faf55ac6eafe3249ecfea528e2b6940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4faf55ac6eafe3249ecfea528e2b6940">&#9670;&#160;</a></span>removeFromNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Compare&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_tree.html">BTree</a>&lt; Key, Value, Compare &gt;::removeFromNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_b_tree_1_1_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes a key from the subtree rooted at <span class="tt">node</span>, preserving B-Tree invariants.</p>
<p>This routine handles three major scenarios:</p><ol type="1">
<li>If <span class="tt">node</span> is a leaf and contains <span class="tt">key</span>, it erases the entry directly.</li>
<li>If <span class="tt">node</span> is internal and contains <span class="tt">key</span>, it replaces <span class="tt">key</span> with its predecessor or successor—or merges children when neither side can lend— then continues removal in the affected subtree.</li>
<li>If <span class="tt">key</span> is not present in <span class="tt">node</span>, it locates the correct child slot, ensures that child has enough entries (borrowing or merging if underflow), and recurses into that child.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Pointer to the node where removal begins. </td></tr>
    <tr><td class="paramname">key</td><td>The key to remove from the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6b60d197dd19c852555521973110479" name="ac6b60d197dd19c852555521973110479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b60d197dd19c852555521973110479">&#9670;&#160;</a></span>rend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Compare&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_b_tree.html">BTree</a>&lt; Key, Value, Compare &gt;::rend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator one past the first (smallest) element. </p>
<p>This marks the end of a reverse in-order traversal.</p>
<dl class="section return"><dt>Returns</dt><dd>A std::reverse_iterator over <a class="el" href="class_b_tree_1_1_iterator.html">Iterator</a> at the rend position. </dd></dl>

</div>
</div>
<a id="a6ac491a77f862fa00a94cf7a688d7e48" name="a6ac491a77f862fa00a94cf7a688d7e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac491a77f862fa00a94cf7a688d7e48">&#9670;&#160;</a></span>search()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Compare&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Value * <a class="el" href="class_b_tree.html">BTree</a>&lt; Key, Value, Compare &gt;::search </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches for the value associated with a given key. </p>
<p>Traverses the tree to locate the node matching key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to look up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the stored value if found; nullptr if the key is not in the tree. </dd></dl>

</div>
</div>
<a id="a4a1d1d6517f181018efa489d009d0fcc" name="a4a1d1d6517f181018efa489d009d0fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a1d1d6517f181018efa489d009d0fcc">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Compare&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_b_tree.html">BTree</a>&lt; Key, Value, Compare &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of key/value pairs stored in the tree. </p>
<p>This size of the B+Tree is updated during insertions and deletions and thus not computed.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of entries in the tree. </dd></dl>

</div>
</div>
<a id="a644946dc5c2b58a1c7ddf8d52fa1b2e8" name="a644946dc5c2b58a1c7ddf8d52fa1b2e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644946dc5c2b58a1c7ddf8d52fa1b2e8">&#9670;&#160;</a></span>splitChild()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Compare&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_tree.html">BTree</a>&lt; Key, Value, Compare &gt;::splitChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_b_tree_1_1_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Divides a full child node into two siblings by moving the upper half of its entries into a new node, promotes the median key into the parent, and links the new sibling so the tree remains balanced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>The parent of the node to split. </td></tr>
    <tr><td class="paramname">index</td><td>The index in the node where to to split. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="btree_8h_source.html">btree.h</a></li>
<li>src/<a class="el" href="btree_8cpp_source.html">btree.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="class_b_tree.html">BTree</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
